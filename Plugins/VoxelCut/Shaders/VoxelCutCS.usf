#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// 预计算的SDF立方体贴图
TextureCube SDFTexture;
SamplerState SDFSampler;

// 体素节点数据结构
struct FOctreeNodeData
{
	float3 BoundsMin;
	float3 BoundsMax;
	uint bIsLeaf;
	uint bIsEmpty;
	uint VoxelsPerSide;
	uint ChildCount;
	uint ChildOffset;
};

// 八叉树节点缓冲区
StructuredBuffer<FOctreeNodeData> OctreeNodes : register(t0);
// 体素数据缓冲区
RWStructuredBuffer<float> Voxels : register(u0);

// 工具SDF采样函数
float SampleToolSDF(float3 WorldPos, float3 SDFBoundsMin, float3 SDFBoundsMax, float BoundsExpansion, Texture3D SDFTexture, SamplerState SDFSampler)
{
	// 1. 将世界位置映射到SDF边界内的局部坐标
	float3 LocalPos = WorldPos - SDFBoundsMin;
	float3 SDFExtent = SDFBoundsMax - SDFBoundsMin;
    
	// 2. 计算归一化的UVW坐标 [0,1]范围
	float3 UVW = LocalPos / SDFExtent;
    
	// 3. 直接采样3D纹理
	float EncodedDist = SDFTexture.SampleLevel(SDFSampler, UVW, 0);
    
	// 4. 解码为原始符号距离
	float NormDist = (EncodedDist * 2.0f) - 1.0f;
	return NormDist * BoundsExpansion;
}

[numthreads(8, 8, 8)]
void MainCS(uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	// 计算当前处理的体素索引
	uint VoxelIndex = DispatchThreadId.x + 
					 DispatchThreadId.y * 64 + 
					 DispatchThreadId.z * 64 * 64;

	// 参数通过宏自动绑定，直接使用即可
	float3 WorldPos = CalculateWorldPos(DispatchThreadId);    

	// 3. 检查是否在更新范围内
	if (any(WorldPos < UpdateBoundsMin) || any(WorldPos > UpdateBoundsMax))
		return;

	// 4. 计算工具距离
	float ToolDistance = SampleToolSDF(
		WorldPos, 
		Parameters.SDFBoundsMin, 
		Parameters.SDFBoundsMax, 
		Parameters.BoundsExpansion,
		Parameters.SDFTexture,
		Parameters.SDFSampler
	);
    
	// 5. 更新体素值
	float CurrentValue = Voxels[VoxelIndex];
    
	// 切削逻辑：如果工具在内部，设为正值（外部）
	if (ToolDistance < 0 && CurrentValue < 0)
	{
		Voxels[VoxelIndex] = abs(CurrentValue);
	}
}