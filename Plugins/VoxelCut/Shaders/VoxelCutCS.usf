#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// 定义体素节点结构（与C++中的FlatOctreeNode一致）
struct FlatOctreeNode
{
	float3 BoundsMin;
	float3 BoundsMax;
	float Voxels[8];
};

// 工具变换矩阵（从C++传递的UniformBuffer）
cbuffer ToolTransformUniformBuffer : register(b0)
{
	float4x4 ToolTransform;
};

// 输入/输出缓冲区
StructuredBuffer<FlatOctreeNode> InputBuffer : register(t0);
RWStructuredBuffer<FlatOctreeNode> OutputBuffer : register(u0);


// SDF纹理及采样器
Texture3D ToolSDF : register(t1);
SamplerState ToolSDFSampler : register(s0);

// 线程组大小（与C++中定义的THREADS_X/Y/Z一致）
[numthreads(8, 1, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint NodeIndex = DispatchThreadId.x;
	FlatOctreeNode Node = InputBuffer[NodeIndex];

	// 计算节点的中心点和尺寸
	float3 NodeCenter = (Node.BoundsMin + Node.BoundsMax) * 0.5;
	float3 NodeExtent = Node.BoundsMax - Node.BoundsMin;
	float3 VoxelStep = NodeExtent / 1.0; // 2x2x2体素的步长（每个维度分2段）

	// 遍历8个体素（2x2x2网格）
	for (int i = 0; i < 8; i++)
	{
		// 计算体素在节点内的本地坐标（0或1，对应2x2x2的8个顶点）
		int3 VoxelLocalPos = int3(
			(i & 1) ? 1 : 0,
			(i & 2) ? 1 : 0,
			(i & 4) ? 1 : 0
		);

		// 计算体素在世界空间中的位置
		float3 VoxelWorldPos = Node.BoundsMin + VoxelLocalPos * VoxelStep;

		// 1. 将体素世界坐标转换到工具的局部空间
		float4 VoxelToolLocal = mul(float4(VoxelWorldPos, 1.0), inverse(ToolTransform));
		float3 VoxelToolPos = VoxelToolLocal.xyz;

		// 2. 计算SDF纹理的UVW坐标（将工具局部空间位置映射到[0,1]范围）
		// SDF纹理的边界信息在C++中已通过FToolSDFGenerator预处理
		// 这里假设SDF的有效范围是工具网格的边界，通过纹理采样自动 clamp
		float3 SDFUVW = VoxelToolPos; // 实际使用时可能需要根据SDFBounds进行归一化

		// 采样原始带符号距离（无需解码）
		int16 RawSDF = ToolSDF.SampleLevel(ToolSDFSampler, SDFUVW, 0).r;
		float SignedDist = (float)RawSDF;  // 直接转换为浮点值

		// 4. 判断体素是否在工具内部（SDF < 0表示内部）
		if (SignedDist < 0.0)
		{
			// 体素在工具内部，将其值设为正（表示被切割）
			Node.Voxels[i] = abs(Node.Voxels[i]); // 保留距离大小，转为正值
		}
	}

	// 写入输出缓冲区
	OutputBuffer[NodeIndex] = Node;
}