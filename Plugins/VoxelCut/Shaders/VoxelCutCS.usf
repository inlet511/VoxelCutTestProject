#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// 定义体素节点结构（与C++中的FlatOctreeNode一致）
struct FlatOctreeNode
{
	float3 BoundsMin;
	float3 BoundsMax;
	float Voxel;
};

// 输入/输出缓冲区
StructuredBuffer<FlatOctreeNode> InputBuffer;
RWStructuredBuffer<FlatOctreeNode> OutputBuffer;

// SDF纹理及采样器
Texture3D ToolSDF;
SamplerState ToolSDFSampler;

// 线程组大小
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	
	uint NodeIndex = DispatchThreadId.x;
	FlatOctreeNode Node = InputBuffer[NodeIndex];

	// 计算节点的中心点和尺寸
	float3 NodeExtent = Node.BoundsMax - Node.BoundsMin;
    float3 NodeCenter = (Node.BoundsMin + Node.BoundsMax) * 0.5f;


	// 计算体素在世界空间中的位置
    float3 VoxelWorldPos = NodeCenter;

	// 1. 将体素世界坐标转换到工具的局部空间
    float4 VoxelToolLocal = mul(float4(VoxelWorldPos, 1.0), ToolUB.ToolInverseTransform);

	bool bInBounds =
		VoxelToolLocal.x >= ToolUB.ToolBoundsLocalMin.x && VoxelToolLocal.x <= ToolUB.ToolBoundsLocalMax.x &&
		VoxelToolLocal.y >= ToolUB.ToolBoundsLocalMin.y && VoxelToolLocal.y <= ToolUB.ToolBoundsLocalMax.y &&
		VoxelToolLocal.z >= ToolUB.ToolBoundsLocalMin.z && VoxelToolLocal.z <= ToolUB.ToolBoundsLocalMax.z;
	if (!bInBounds)
        return;

	// 2. 计算SDF纹理的UVW坐标（将工具局部空间位置映射到[0,1]范围）
    float3 SDFSize = ToolUB.ToolBoundsLocalMax - ToolUB.ToolBoundsLocalMin;
    float3 SDFUVW = (VoxelToolLocal.xyz - ToolUB.ToolBoundsLocalMin) / SDFSize;

	// 修正纹理坐标：将[0,1]范围映射到纹理像素中心（避免采样偏差）
    float3 HalfVoxelSize = 1.0f / (2.0f * ToolUB.VolumeTextureSize);
    SDFUVW = SDFUVW * (1.0f - 2.0f * HalfVoxelSize) + HalfVoxelSize;
	
	// 采样原始带符号距离（无需解码）
    float SignedDist = ToolSDF.SampleLevel(ToolSDFSampler, SDFUVW,0).x;
	// 注意这里不能使用Sample()函数，Package会报错

	// 4. 判断体素是否在工具内部（SDF < 0表示内部）
	if (SignedDist < 0.0)
	{
		// 体素在工具内部，将其值设为正（表示被切割）
		Node.Voxel = abs(Node.Voxel); // 保留距离大小，转为正值
	}	

	// 写入输出缓冲区
	OutputBuffer[NodeIndex] = Node;
}