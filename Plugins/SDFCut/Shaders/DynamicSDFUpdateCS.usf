
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "SharedData.ush"


struct FCutterGlobalParams
{
    float IsoValue;
    float CubeSize;
    float4x4 ToolTransform;
    float4x4 ToolInverseTransform;
    FAxisAlignedBox3f ToolAABB;
};


Texture3D<float> OriginalSDF;
SamplerState OriginalSDFSampler;
Texture3D<float> ToolSDF;
SamplerState ToolSDFSampler;
RWTexture3D<float> DynamicSDF;


// 采样SDF纹理（将世界坐标转换为纹理UV）
float SampleSDF(Texture3D<float> SDFTex, SamplerState Sampler, float3 WorldPos, FAxisAlignedBox SDFBounds)
{
    float3 UV = saturate((WorldPos - SDFBounds.Min) / (SDFBounds.Max - SDFBounds.Min));
    return SDFTex.SampleLevel(Sampler, UV, 0).r;
}

// 计算体素在世界空间的位置
float3 GetVoxelWorldPos(FIntVector VoxelIndex, FAxisAlignedBox Bounds, FIntVector Dimensions)
{
    float3 Step = (Bounds.Max - Bounds.Min) / Dimensions;
    return Bounds.Min + (VoxelIndex + 0.5f) * Step; // 体素中心点
}

[numthreads(4, 4, 4)]
void LocalSDFUpdateKernel(uint3 DispatchThreadID : SV_DispatchThreadID)
{
    // 转换为全局体素坐标
    int3 GlobalVoxelID = CutUB.UpdateRegionMin + DispatchThreadID;
    
    // 边界检查
    if (any(GlobalVoxelID >= CutUB.UpdateRegionMax) || any(GlobalVoxelID < int3(0,0,0)))
        return;

    // 1. 计算物体局部坐标（直接操作，不需要世界坐标转换）
    float3 ObjectPos = VoxelToObjectPos(GlobalVoxelID, CutUB.SDFDimensions, CutUB.ObjectLocalBounds);
    
    // 2. 采样原始物体SDF（直接在物体局部坐标系）
    float3 ObjectUV = ObjectPosToUV(ObjectPos, CutUB.ObjectLocalBounds);
    float OriginalSDFValue = OriginalSDF.SampleLevel(OriginalSDFSampler, ObjectUV, 0);
    
    // 3. 将物体局部坐标转换到工具局部坐标系
    float4 ToolSpacePos4 = mul(CutUB.ObjectToToolTransform, float4(ObjectPos, 1.0));
    float3 ToolSpacePos = ToolSpacePos4.xyz / ToolSpacePos4.w;
    
    // 4. 检查是否在工具边界内（快速剔除）
    if (!IsInToolLocalBounds(ToolSpacePos, CutUB.ToolLocalBounds))
        return;
    
    // 5. 采样工具SDF（工具局部坐标系）
    float3 ToolUV = ToolPosToUV(ToolSpacePos, CutUB.ToolLocalBounds);
    float ToolSDFValue = ToolSDF.SampleLevel(ToolSDFSampler, ToolUV, 0);
    
    // 6. 布尔运算：切削 = 保留物体内部(负值)且不在工具内部(正值)的部分
    // 等价于：Result = max(OriginalSDF, -ToolSDF)
    // - 如果工具SDF为负（在工具内部）：-ToolSDF为正，结果为正 → 被切削掉
    // - 如果工具SDF为正（在工具外部）：-ToolSDF为负，保留OriginalSDF
    float ResultSDF = max(OriginalSDFValue, -ToolSDFValue);
    
    // 7. 写入结果
    DynamicSDF[GlobalVoxelID] = ResultSDF;
}