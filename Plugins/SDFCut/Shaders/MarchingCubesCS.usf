
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "MarchingCubesConsts.ush"


Texture3D<float> DynamicSDF;
RWStructuredBuffer<float3> OutVertices;
RWStructuredBuffer<int3> OutTriangles;
RWBuffer<int> VertexCounter;
RWBuffer<int> TriangleCounter;




// 采样动态SDF
float SampleDynamicSDF(Texture3D<float> DynamicSDF, float3 WorldPos, float3 BoundsMin, float3 BoundsMax, int3 Dimensions)
{
    float3 UV = (WorldPos - BoundsMin) / (BoundsMax - BoundsMin);
    int3 VoxelIndex = int3(saturate(UV) * Dimensions);
    return DynamicSDF[VoxelIndex];
}

// 计算体素8个角点的SDF值
void SampleCubeSDF(Texture3D<float> DynamicSDF, float3 CubePos, float CubeSize,  float3 BoundsMin, float3 BoundsMax, int3 Dimensions, out float Values[8])
{
    float3 HalfSize = float3(CubeSize * 0.5f, CubeSize * 0.5f, CubeSize * 0.5f);
    Values[0] = SampleDynamicSDF(DynamicSDF, CubePos + float3(-HalfSize.x, -HalfSize.y, -HalfSize.z), BoundsMin, BoundsMax, Dimensions);
    Values[1] = SampleDynamicSDF(DynamicSDF, CubePos + float3(HalfSize.x, -HalfSize.y, -HalfSize.z), BoundsMin, BoundsMax, Dimensions);
    Values[2] = SampleDynamicSDF(DynamicSDF, CubePos + float3(HalfSize.x, HalfSize.y, -HalfSize.z), BoundsMin, BoundsMax, Dimensions);
    Values[3] = SampleDynamicSDF(DynamicSDF, CubePos + float3(-HalfSize.x, HalfSize.y, -HalfSize.z), BoundsMin, BoundsMax, Dimensions);
    Values[4] = SampleDynamicSDF(DynamicSDF, CubePos + float3(-HalfSize.x, -HalfSize.y, HalfSize.z), BoundsMin, BoundsMax, Dimensions);
    Values[5] = SampleDynamicSDF(DynamicSDF, CubePos + float3(HalfSize.x, -HalfSize.y, HalfSize.z), BoundsMin, BoundsMax, Dimensions);
    Values[6] = SampleDynamicSDF(DynamicSDF, CubePos + float3(HalfSize.x, HalfSize.y, HalfSize.z), BoundsMin, BoundsMax, Dimensions);
    Values[7] = SampleDynamicSDF(DynamicSDF, CubePos + float3(-HalfSize.x, HalfSize.y, HalfSize.z), BoundsMin, BoundsMax, Dimensions);
}

// 计算边的交点
float3 ComputeEdgeIntersection(float3 p0, float f0, float3 p1, float f1, float IsoValue)
{
    if (abs(f0 - f1) < 0.0001f) return (p0 + p1) * 0.5f;
    float t = saturate((IsoValue - f0) / (f1 - f0));
    return lerp(p0, p1, t);
}

[numthreads(8, 8, 8)]
void MarchingCubesKernel(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    int3 CubeIndex = int3(DispatchThreadId.x, DispatchThreadId.y, DispatchThreadId.z);
    
    // 超出动态SDF范围，直接返回
    if (CubeIndex.x >= MCUB.SDFDimensions.x - 1 || 
        CubeIndex.y >= MCUB.SDFDimensions.y - 1 || 
        CubeIndex.z >= MCUB.SDFDimensions.z - 1)
    {
        return;
    }

    // 1. 计算当前立方体的中心位置
    float3 Step = (MCUB.SDFBoundsMax - MCUB.SDFBoundsMin) / MCUB.SDFDimensions;
    float3 CubePos = MCUB.SDFBoundsMin + (CubeIndex + 0.5f) * Step;

    // 2. 采样立方体8个角点的SDF值
    float SDFValues[8];
    SampleCubeSDF(DynamicSDF, CubePos, MCUB.CubeSize, MCUB.SDFBoundsMin, MCUB.SDFBoundsMax, MCUB.SDFDimensions, SDFValues);

    // 3. 计算立方体编码（判断每个角点是否在等值面内）
    int CubeCode = 0;
    for (int i = 0; i < 8; i++)
    {
        if (SDFValues[i] < MCUB.IsoValue)
        {
            CubeCode |= (1u << i);
        }
    }

    // 4. 无等值面，直接返回
    if (EdgeTable[CubeCode] == 0) return;

    // 5. 计算边交点
    float3 EdgeVertices[12];
    int EdgeVertexIndices[12];
    for (int i = 0; i < 12; i++)
    {
        if (EdgeTable[CubeCode] & (1u << i))
        {
            int A = EdgeIndices[i][0];
            int B = EdgeIndices[i][1];
            float3 P0 = CubePos + float3(
                (A & 1) ? Step.x * 0.5f : -Step.x * 0.5f,
                (A & 2) ? Step.y * 0.5f : -Step.y * 0.5f,
                (A & 4) ? Step.z * 0.5f : -Step.z * 0.5f
            );
            float3 P1 = CubePos + float3(
                (B & 1) ? Step.x * 0.5f : -Step.x * 0.5f,
                (B & 2) ? Step.y * 0.5f : -Step.y * 0.5f,
                (B & 4) ? Step.z * 0.5f : -Step.z * 0.5f
            );
            EdgeVertices[i] = ComputeEdgeIntersection(P0, SDFValues[A], P1, SDFValues[B], MCUB.IsoValue);
            
            // 原子操作分配顶点索引（避免并发冲突）
        	int originalVetexCount;
            InterlockedAdd(VertexCounter[0], 1 , originalVetexCount);
        	int VertexIndex = originalVetexCount;
            OutVertices[VertexIndex] = EdgeVertices[i];
        	
        	EdgeVertexIndices[i] = VertexIndex;
        }else
        {
	        EdgeVertexIndices[i] = -1;
        }
    	
    }

    // 6. 生成三角形
    for (int i = 0; TriTable[CubeCode][i] != -1; i += 3)
    {
        int Idx0 = TriTable[CubeCode][i];
        int Idx1 = TriTable[CubeCode][i + 1];
        int Idx2 = TriTable[CubeCode][i + 2];

        if (Idx0 >= 0 && Idx1 >= 0 && Idx2 >= 0 &&
			EdgeVertexIndices[Idx0] != -1 && 
			EdgeVertexIndices[Idx1] != -1 && 
			EdgeVertexIndices[Idx2] != -1)
        {
        	int originalTriCount;
        	InterlockedAdd(TriangleCounter[0], 1, originalTriCount);
        	int TriIndex = originalTriCount;
            OutTriangles[TriIndex] = int3(EdgeVertexIndices[Idx0], EdgeVertexIndices[Idx1], EdgeVertexIndices[Idx2]);
        }
    }
}