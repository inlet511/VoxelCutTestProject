#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// 定义体素节点结构（与C++中的FlatOctreeNode一致）
struct FlatOctreeNode
{
	float3 BoundsMin;
	float3 BoundsMax;
	float Voxels[8];
};

// 输入/输出缓冲区
StructuredBuffer<FlatOctreeNode> InputBuffer;
RWStructuredBuffer<FlatOctreeNode> OutputBuffer;


// SDF纹理及采样器
Texture3D ToolSDF;
SamplerState ToolSDFSampler;

// 线程组大小（与C++中定义的THREADS_X/Y/Z一致）
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	/*
	uint NodeIndex = DispatchThreadId.x;
	FlatOctreeNode Node = InputBuffer[NodeIndex];

	// 计算节点的中心点和尺寸
	float3 NodeExtent = Node.BoundsMax - Node.BoundsMin;
	float3 VoxelStep = NodeExtent;

	// 遍历8个体素（2x2x2网格）
	for (int i = 0; i < 8; i++)
	{
		// 计算体素在节点内的本地坐标（0或1，对应2x2x2的8个顶点）
		int3 VoxelLocalPos = int3(
			(i & 1) ? 1 : 0,
			(i & 2) ? 1 : 0,
			(i & 4) ? 1 : 0
		);

		// 计算体素在世界空间中的位置
		float3 VoxelWorldPos = Node.BoundsMin + VoxelLocalPos * VoxelStep;

		// 1. 将体素世界坐标转换到工具的局部空间
		float4 VoxelToolLocal = mul(float4(VoxelWorldPos, 1.0), ToolTransformUniformBuffer.ToolTransform);
		float3 VoxelToolPos = VoxelToolLocal.xyz;

		bool bInBounds =
			VoxelToolPos.x >= SDFBoundsUniformBuffer.SDFBoundsMin.x && VoxelToolPos.x <= SDFBoundsUniformBuffer.SDFBoundsMax.x &&
			VoxelToolPos.y >= SDFBoundsUniformBuffer.SDFBoundsMin.y && VoxelToolPos.y <= SDFBoundsUniformBuffer.SDFBoundsMax.y &&
			VoxelToolPos.z >= SDFBoundsUniformBuffer.SDFBoundsMin.z && VoxelToolPos.z <= SDFBoundsUniformBuffer.SDFBoundsMax.z;
		if (!bInBounds)
			continue;

		// 2. 计算SDF纹理的UVW坐标（将工具局部空间位置映射到[0,1]范围）
		// 计算UVW（使用UniformBuffer中的VolumeTextureSize）
		float3 SDFExtent = SDFBoundsUniformBuffer.SDFBoundsMax - SDFBoundsUniformBuffer.SDFBoundsMin;
		float3 SDFUVW = (VoxelToolPos - SDFBoundsUniformBuffer.SDFBoundsMin) / SDFExtent;

		int3 SDFTexCoord = int3(SDFUVW * SDFBoundsUniformBuffer.VolumeTextureSize);
		SDFTexCoord = clamp(SDFTexCoord, int3(0,0,0), int3(SDFBoundsUniformBuffer.VolumeTextureSize - 1, SDFBoundsUniformBuffer.VolumeTextureSize - 1, SDFBoundsUniformBuffer.VolumeTextureSize - 1));
		
		// 采样原始带符号距离（无需解码）
		int RawSDF_Int = ToolSDF.Load(int4(SDFTexCoord, 0)).r; // Load直接读整数，无需归一化
		half RawSDF = (half)RawSDF_Int; // 转换为16位有符号整数
		float SignedDist = (float)RawSDF; // 转换为浮点值

		// 4. 判断体素是否在工具内部（SDF < 0表示内部）
		if (SignedDist < 0.0)
		{
			// 体素在工具内部，将其值设为正（表示被切割）
			Node.Voxels[i] = abs(Node.Voxels[i]); // 保留距离大小，转为正值
		}
	}

	// 写入输出缓冲区
	OutputBuffer[NodeIndex] = Node;
*/

}